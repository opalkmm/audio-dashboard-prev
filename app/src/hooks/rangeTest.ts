import { useState, useEffect, useCallback } from 'react';

/*
 * This code was generated by ChatGPT 4.0
 */

type UseVocalRangeHook = {
  frequency: number | null;
  vocalRange: string | null;
  error: string | null;
  start: () => void;
  stop: () => void;
};

export const useVocalRange = (): UseVocalRangeHook => {
  const [frequency, setFrequency] = useState<number | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [audioContext, setAudioContext] = useState<AudioContext | null>(null);

  const getVocalRange = (frequency: number | null): string | null => {
    if (!frequency) return null;
    if (frequency >= 82.41 && frequency <= 329.63) return 'Bass';
    if (frequency >= 110 && frequency <= 440) return 'Baritone';
    if (frequency >= 130.81 && frequency <= 523.25) return 'Tenor';
    if (frequency >= 174.61 && frequency <= 698.46) return 'Alto';
    if (frequency >= 220.00 && frequency <= 880.00) return 'Mezzo-Soprano';
    if (frequency >= 261.63 && frequency <= 1046.5) return 'Soprano';
    return 'Out of range';
  };

  const vocalRange = getVocalRange(frequency);

  const start = useCallback(() => {
    const context = new window.AudioContext();
    setAudioContext(context);
  }, []);

  const stop = useCallback(() => {
    if (audioContext && audioContext.state !== 'closed') {
      audioContext.close();
      setAudioContext(null);
    }
  }, [audioContext]);

  useEffect(() => {
    if (!audioContext) return;

    const analyser = audioContext.createAnalyser();

    navigator.mediaDevices
      .getUserMedia({ audio: true, video: false })
      .then((stream) => {
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);

        const frequencyData = new Uint8Array(analyser.frequencyBinCount);
        const updateFrequency = () => {
          requestAnimationFrame(updateFrequency);
          analyser.getByteFrequencyData(frequencyData);

          const maxIndex = frequencyData.reduce(
            (iMax, x, i, arr) => (x > arr[iMax] ? i : iMax),
            0
          );
          const frequency =
            (maxIndex * audioContext.sampleRate) / (2 * analyser.fftSize);

          setFrequency(frequency);
        };

        updateFrequency();
      })
      .catch((err) => {
        setError(err.message);
      });

    return () => {
      stop();
    };
  }, [audioContext, stop]);

  return { frequency, vocalRange, error, start, stop };
};
